JavaScript: const uniqueCodes = new Set();
Python equivalent: unique_codes = set()
JavaScriptâ€™s Set is identical to Pythonâ€™s set. It stores unique values and has a size property (like Pythonâ€™s len(set)).
###############################################
JavaScript: for (let word of words) { ... }
Python equivalent: for word in words: ...
JavaScriptâ€™s for...of loop is like Pythonâ€™s for...in for iterating over arrays or strings.
####################################################
JavaScript: char.charCodeAt(0) - 'a'.charCodeAt(0)
Python equivalent: ord(char) - ord('a')
charCodeAt(0) returns the ASCII code of a character (like Pythonâ€™s ord). Subtracting 'a'.charCodeAt(0) (ASCII 97) maps 'a' to 0, 'b' to 1, etc.,
to index into morseTable.
We build the Morse code string with morse += ..., like Pythonâ€™s string concatenation (morse += ...).
######################################################
Adding to Set:

JavaScript: uniqueCodes.add(morse);
Python equivalent: unique_codes.add(morse)
Identical functionality: adds the Morse code string to the Set, ignoring duplicates.
#####################################################
JavaScript: return uniqueCodes.size;
Python equivalent: return len(unique_codes)
Set.size in JavaScript is like len(set) in Python.
########################################################
sort
python .sort() method, list.sort() or list.sort(reverse=True)
or sorted function, sorted(list) and sorted(list, reverse=True)

In JavaScript, you use the .sort() method. By default, .sort() converts items to strings and sorts them lexicographically (which can give unexpected results with numbers). 
To sort numbers properly, you pass a compare function.
let sortedlist = list.sort((a, b) => a - b);

ðŸ”¹ Descending order
let sortedlist = list.sort((a, b) => b-a);
The .sort() method modifies the original array in JavaScript (unlike Pythonâ€™s sorted() which creates a copy).

If you want to keep the original untouched, clone first:
let sortedlist = [...list].sort((a, b) => a - b);
///////////////////////////////////////////////
//In JavaScript, comparing arrays with === (or ==) doesnâ€™t check if they have the same contents â€” it only checks if theyâ€™re the same object in memory.
Since ascending and descending are new arrays, theyâ€™ll never be strictly equal to nums.
Fix using .every() to compare values:

let ascending = [...nums].sort((a, b) => a - b);
    let descending = [...nums].sort((a, b) => b - a);

    let isAscending = nums.every((val, i) => val === ascending[i]);
    let isDescending = nums.every((val, i) => val === descending[i]);

//////////////////////////////////////////////////////

